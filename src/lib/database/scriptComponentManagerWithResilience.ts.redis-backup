/**
 * ScriptComponentManager with Circuit Breaker Resilience
 *
 * Technical Architect: Implementing resilience patterns for CRUD operations
 * This wrapper adds circuit breaker protection to all database operations
 * to prevent cascade failures and provide graceful degradation
 */

// Context7: consulted for @supabase/supabase-js
import { SupabaseClient } from '@supabase/supabase-js';
// Context7: consulted for opossum
import CircuitBreaker from 'opossum';
// Context7: consulted for ioredis
import Redis from 'ioredis';
import { ScriptComponentManager } from './scriptComponentManager';
import {
  UpdateResult,
  BatchUpdateOperation,
  BatchUpdateResult,
  OptimisticLockMetrics,
  DeleteResult,
  RestoreResult,
  BulkDeleteResult,
  PositionUpdateResult,
  ScriptComponent,
  ComponentsListResult,
  ComponentReadResult
} from '../../types/scriptComponent';

// Redis configuration interface
interface RedisConfig {
  redisInstance?: Redis | unknown; // Allow mock instances
  url?: string;
  disableWorker?: boolean;
}

// Type definitions for circuit breaker operation parameters
interface CreateParams {
  scriptId: string;
  content: object;
  plainText: string;
  position?: number;
  status: string;
  userId: string;
}

interface UpdateParams {
  componentId: string;
  content: object;
  plainText: string;
  currentVersion: number;
  userId: string;
}

interface DeleteParams {
  componentId: string;
  userId: string;
  reason?: string;
}

interface RestoreParams {
  componentId: string;
  userId: string;
}

interface GetComponentsParams {
  scriptId: string;
  includeDeleted: boolean;
}

interface GetComponentParams {
  componentId: string;
  includeDeleted: boolean;
}

interface BulkDeleteParams {
  componentIds: string[];
  userId: string;
  reason?: string;
}

interface UpdatePositionsParams {
  updates: Array<{ componentId: string; position: number }>;
}

interface BatchUpdateParams {
  operations: BatchUpdateOperation[];
}

type CircuitBreakerParams = CreateParams | UpdateParams | DeleteParams | RestoreParams |
                           GetComponentsParams | GetComponentParams | BulkDeleteParams |
                           UpdatePositionsParams | BatchUpdateParams;

/**
 * Circuit breaker configuration for database operations
 */
const CIRCUIT_BREAKER_CONFIG = {
  timeout: 5000, // 5 seconds timeout
  errorThresholdPercentage: 30, // Open circuit at 30% error rate
  resetTimeout: 20000, // Try half-open after 20 seconds
  rollingCountTimeout: 10000, // 10 second rolling window
  rollingCountBuckets: 10, // 10 buckets of 1 second each
  volumeThreshold: 5, // Minimum 5 requests before calculating error rate
  fallback: true, // Enable fallback functions
  allowWarmUp: true // Allow gradual traffic increase in half-open state
};

/**
 * Enhanced ScriptComponentManager with circuit breaker protection
 */
export class ResilientScriptComponentManager {
  private manager: ScriptComponentManager;
  private circuitBreakers: Map<string, CircuitBreaker>;
  private redis: Redis;
  private readonly QUEUE_KEY = 'offline_operations';
  private readonly PROCESSING_KEY = 'processing_operations';
  private readonly DLQ_KEY = 'dlq_operations';
  private readonly MAX_OFFLINE_QUEUE_SIZE = 100;
  private readonly MAX_RETRIES = 3;
  private workerProcessActive = false;
  private workerId: string = `worker_${Math.random().toString(36).substring(2)}`;
  private workerStats = {
    processedCount: 0,
    errorCount: 0,
    dlqCount: 0,
    lastProcessedAt: new Date()
  };

  constructor(supabaseClient: SupabaseClient, redisConfig?: RedisConfig) {
    this.manager = new ScriptComponentManager(supabaseClient);
    this.circuitBreakers = new Map();

    // Critical-Engineer: consulted for Persistent queue architecture and reliability
    // Allow Redis instance injection for testing
    if (redisConfig?.redisInstance) {
      this.redis = redisConfig.redisInstance as Redis;
    } else {
      // Initialize Redis connection with robust error handling and TLS enforcement
      const redisUrl = redisConfig?.url || process.env.REDIS_URL || 'redis://localhost:6379';

      // Enforce TLS for production environments
      if (process.env.NODE_ENV === 'production' && !redisUrl.startsWith('rediss://')) {
        throw new Error('Production environments must use TLS Redis connections (rediss://)');
      }

      this.redis = new Redis(redisUrl, {
        enableOfflineQueue: false, // We handle our own reliable offline queue
        maxRetriesPerRequest: 3,
        retryStrategy: (times) => Math.min(times * 50, 2000), // Exponential backoff capped at 2s
        lazyConnect: false,
        reconnectOnError: (err: Error) => {
          const targetError = 'READONLY';
          return err.message.includes(targetError);
        }
      });
    }

    this.initializeCircuitBreakers();

    // Allow disabling worker process for testing
    if (!redisConfig?.disableWorker) {
      this.startWorkerProcess();
    }
  }

  /**
   * Initialize circuit breakers for each operation type
   */
  private initializeCircuitBreakers(): void {
    // Create component circuit breaker
    this.createCircuitBreaker('create', async (params: CreateParams) => {
      return this.manager.createComponent(
        params.scriptId,
        params.content,
        params.plainText,
        params.userId,
        params.position,
        params.status
      );
    });

    // Update component circuit breaker
    this.createCircuitBreaker('update', async (params: UpdateParams) => {
      return this.manager.updateComponent(
        params.componentId,
        params.content,
        params.plainText,
        params.currentVersion,
        params.userId
      );
    });

    // Delete component circuit breaker
    this.createCircuitBreaker('delete', async (params: DeleteParams) => {
      return this.manager.deleteComponent(
        params.componentId,
        params.userId,
        params.reason
      );
    });

    // Restore component circuit breaker
    this.createCircuitBreaker('restore', async (params: RestoreParams) => {
      return this.manager.restoreComponent(
        params.componentId,
        params.userId
      );
    });

    // Get components circuit breaker
    this.createCircuitBreaker('getComponents', async (params: GetComponentsParams) => {
      return this.manager.getComponentsByScriptId(
        params.scriptId,
        params.includeDeleted
      );
    });

    // Get single component circuit breaker
    this.createCircuitBreaker('getComponent', async (params: GetComponentParams) => {
      return this.manager.getComponentById(
        params.componentId,
        params.includeDeleted
      );
    });

    // Bulk delete circuit breaker
    this.createCircuitBreaker('bulkDelete', async (params: BulkDeleteParams) => {
      return this.manager.bulkDeleteComponents(
        params.componentIds,
        params.userId,
        params.reason
      );
    });

    // Update positions circuit breaker
    this.createCircuitBreaker('updatePositions', async (params: UpdatePositionsParams) => {
      return this.manager.updateComponentPositions(params.updates.map(u => ({
        componentId: u.componentId,
        position: Number(u.position) // Ensure it's a number
      })));
    });

    // Batch update circuit breaker
    this.createCircuitBreaker('batchUpdate', async (params: BatchUpdateParams) => {
      return this.manager.updateMultipleComponents(params.operations);
    });
  }

  /**
   * Create a circuit breaker with fallback and monitoring
   */
  private createCircuitBreaker<T extends CircuitBreakerParams, R>(
    name: string,
    operation: (params: T) => Promise<R>
  ): void {
    const breaker = new CircuitBreaker(operation, {
      ...CIRCUIT_BREAKER_CONFIG,
      name
    });

    // Set up fallback
    breaker.fallback((params: T) => this.handleFallback(name, params));

    // Monitor circuit breaker events
    breaker.on('open', () => {
      console.warn(`Circuit breaker ${name} opened`);
    });

    breaker.on('halfOpen', () => {
      console.info(`Circuit breaker ${name} is half-open, testing...`);
    });

    breaker.on('close', () => {
      console.info(`Circuit breaker ${name} closed, normal operation resumed`);
      // Redis queue processing is handled by the continuous worker process
      // No explicit processing needed here as the worker will pick up operations
    });

    breaker.on('fallback', (data: unknown) => {
      console.warn(`Circuit breaker ${name} fallback triggered`, data);
    });

    this.circuitBreakers.set(name, breaker);
  }

  /**
   * Handle fallback when circuit is open
   */
  private handleFallback(
    operation: string,
    params: CircuitBreakerParams
  ): UpdateResult | DeleteResult | RestoreResult | ComponentsListResult | ComponentReadResult | BulkDeleteResult | PositionUpdateResult | BatchUpdateResult[] | { success: false; error: string; queued?: boolean } {
    // Queue operation for retry when circuit closes using Redis
    this.queueOperationToRedis(operation, params).catch(error => {
      console.error('Failed to queue operation to Redis:', error);
    });

    // Return appropriate fallback response
    switch (operation) {
      case 'create':
        return {
          success: false,
          error: 'Service temporarily unavailable. Operation queued for retry.',
          queued: true
        };

      case 'update':
        return {
          success: false,
          conflictDetected: false,
          errorMessage: 'Service temporarily unavailable. Operation queued for retry.'
        } as UpdateResult;

      case 'delete':
        return {
          success: false,
          error: 'Service temporarily unavailable. Operation queued for retry.',
          queued: true
        } as DeleteResult;

      case 'restore':
        return {
          success: false,
          error: 'Service temporarily unavailable. Operation queued for retry.'
        } as RestoreResult;

      case 'getComponents':
        return {
          components: [],
          error: 'Unable to fetch components. Service temporarily unavailable.'
        } as ComponentsListResult;

      case 'getComponent':
        return {
          component: undefined,
          error: 'Unable to fetch component. Service temporarily unavailable.'
        } as ComponentReadResult;

      default:
        return {
          success: false,
          error: 'Service temporarily unavailable'
        };
    }
  }

  /**
   * Queue operation to Redis for persistence
   */
  private async queueOperationToRedis(operation: string, params: CircuitBreakerParams): Promise<void> {
    try {
      const queueSize = await this.redis.llen(this.QUEUE_KEY);
      if (queueSize < this.MAX_OFFLINE_QUEUE_SIZE) {
        const queueItem = {
          operation,
          params,
          timestamp: Date.now()
        };
        await this.redis.lpush(this.QUEUE_KEY, JSON.stringify(queueItem));
      }
    } catch (error) {
      console.error('Error queuing operation to Redis:', error);
    }
  }

  /**
   * Start Redis worker process for consuming queue
   */
  private startWorkerProcess(): void {
    if (this.workerProcessActive) return;

    this.workerProcessActive = true;
    this.processRedisQueue();
  }

  /**
   * Process Redis queue continuously with reliable pattern
   * Critical-Engineer: Using BRPOPLPUSH for atomic move to prevent poison pills
   */
  private async processRedisQueue(): Promise<void> {
    if (!this.workerProcessActive) return;

    try {
      // Atomically move from main queue to processing queue
      const queueItemStr = await this.redis.brpoplpush(
        this.QUEUE_KEY,
        `${this.PROCESSING_KEY}:${this.workerId}`,
        1 // 1-second timeout
      );

      if (queueItemStr) {
        const queueItem = JSON.parse(queueItemStr);

        try {
          await this.processQueuedOperation(queueItem);

          // Success: Remove from processing queue
          await this.redis.lrem(`${this.PROCESSING_KEY}:${this.workerId}`, 1, queueItemStr);

          this.workerStats.processedCount++;
          this.workerStats.lastProcessedAt = new Date();
        } catch (processingError) {
          console.error('Error processing operation:', processingError);

          // Check retry count
          const retryCount = queueItem.retryCount || 0;
          const errorMessage = processingError instanceof Error ? processingError.message : String(processingError);

          if (retryCount < this.MAX_RETRIES) {
            // Increment retry count and re-queue
            queueItem.retryCount = retryCount + 1;
            queueItem.lastError = errorMessage;
            queueItem.lastRetryAt = Date.now();

            await this.redis.lpush(this.QUEUE_KEY, JSON.stringify(queueItem));
          } else {
            // Max retries exceeded: Move to Dead Letter Queue
            await this.redis.lpush(this.DLQ_KEY, JSON.stringify({
              ...queueItem,
              movedToDLQAt: Date.now(),
              finalError: errorMessage
            }));
            this.workerStats.dlqCount++;
          }

          // Remove from processing queue
          await this.redis.lrem(`${this.PROCESSING_KEY}:${this.workerId}`, 1, queueItemStr);
          this.workerStats.errorCount++;
        }
      }
    } catch (error) {
      console.error('Error in Redis queue processing:', error);
      this.workerStats.errorCount++;

      // Wait before retrying on connection errors
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    // Continue processing
    if (this.workerProcessActive) {
      setTimeout(() => this.processRedisQueue(), 0);
    }
  }

  /**
   * Process a single queued operation
   */
  private async processQueuedOperation(queueItem: { operation: string; params: unknown; timestamp: number }): Promise<void> {
    try {
      const breaker = this.circuitBreakers.get(queueItem.operation);
      if (breaker && !breaker.opened) {
        await breaker.fire(queueItem.params);
      }
    } catch (error) {
      console.error(`Failed to process queued operation ${queueItem.operation}:`, error);
      // Re-queue if it's a transient error (implement retry logic here if needed)
    }
  }

  /**
   * Create a new script component with circuit breaker protection
   */
  async createComponent(
    scriptId: string,
    content: object = { type: 'doc', content: [] },
    plainText: string = '',
    userId: string,
    position?: number,
    status: string = 'created'
  ): Promise<ScriptComponent | { success: false; error: string; queued?: boolean } | null> {
    const breaker = this.circuitBreakers.get('create');
    return (breaker?.fire({
      scriptId,
      content,
      plainText,
      position,
      status,
      userId
    }) as Promise<ScriptComponent | { success: false; error: string; queued?: boolean }>) || Promise.resolve(null);
  }

  /**
   * Update a component with circuit breaker protection
   */
  async updateComponent(
    componentId: string,
    content: object,
    plainText: string,
    currentVersion: number,
    userId: string
  ): Promise<UpdateResult> {
    const breaker = this.circuitBreakers.get('update');
    return (breaker?.fire({
      componentId,
      content,
      plainText,
      currentVersion,
      userId
    }) as Promise<UpdateResult>) || Promise.resolve({ success: false, conflictDetected: false, errorMessage: 'Circuit breaker not initialized' });
  }

  /**
   * Delete a component with circuit breaker protection
   */
  async deleteComponent(
    componentId: string,
    userId: string,
    reason?: string
  ): Promise<DeleteResult> {
    const breaker = this.circuitBreakers.get('delete');
    return (breaker?.fire({
      componentId,
      userId,
      reason
    }) as Promise<DeleteResult>) || Promise.resolve({ success: false, error: 'Circuit breaker not initialized' } as DeleteResult);
  }

  /**
   * Restore a deleted component with circuit breaker protection
   */
  async restoreComponent(
    componentId: string,
    userId: string
  ): Promise<RestoreResult> {
    const breaker = this.circuitBreakers.get('restore');
    return (breaker?.fire({
      componentId,
      userId
    }) as Promise<RestoreResult>) || Promise.resolve({ success: false, error: 'Circuit breaker not initialized' } as RestoreResult);
  }

  /**
   * Get all components for a script with circuit breaker protection
   */
  async getComponentsByScriptId(
    scriptId: string,
    includeDeleted: boolean = false
  ): Promise<ComponentsListResult> {
    const breaker = this.circuitBreakers.get('getComponents');
    return (breaker?.fire({
      scriptId,
      includeDeleted
    }) as Promise<ComponentsListResult>) || Promise.resolve({ components: [], error: 'Circuit breaker not initialized' });
  }

  /**
   * Get a single component by ID with circuit breaker protection
   */
  async getComponentById(
    componentId: string,
    includeDeleted: boolean = false
  ): Promise<ComponentReadResult | null> {
    const breaker = this.circuitBreakers.get('getComponent');
    return (breaker?.fire({
      componentId,
      includeDeleted
    }) as Promise<ComponentReadResult>) || Promise.resolve(null);
  }

  /**
   * Bulk delete components with circuit breaker protection
   */
  async bulkDeleteComponents(
    componentIds: string[],
    userId: string,
    reason?: string
  ): Promise<BulkDeleteResult> {
    const breaker = this.circuitBreakers.get('bulkDelete');
    return (breaker?.fire({
      componentIds,
      userId,
      reason
    }) as Promise<BulkDeleteResult>) || Promise.resolve({ success: false, deletedCount: 0, failedIds: componentIds, error: 'Circuit breaker not initialized' } as BulkDeleteResult);
  }

  /**
   * Update component positions with circuit breaker protection
   */
  async updateComponentPositions(
    updates: Array<{ componentId: string; position: number }>
  ): Promise<PositionUpdateResult> {
    const breaker = this.circuitBreakers.get('updatePositions');
    return (breaker?.fire({ updates }) as Promise<PositionUpdateResult>) || Promise.resolve({
      success: false,
      updatedCount: 0,
      error: 'Circuit breaker not initialized'
    } as PositionUpdateResult);
  }

  /**
   * Update multiple components in batch with circuit breaker protection
   */
  async updateMultipleComponents(
    operations: BatchUpdateOperation[]
  ): Promise<BatchUpdateResult[]> {
    const breaker = this.circuitBreakers.get('batchUpdate');
    return (breaker?.fire({ operations }) as Promise<BatchUpdateResult[]>) || Promise.resolve([]);
  }

  /**
   * Get component count with circuit breaker protection
   */
  async getComponentsCount(
    scriptId: string,
    includeDeleted: boolean = false
  ): Promise<{ count: number; error?: string }> {
    // Use the base manager directly for simple count operations
    // These are less critical and don't need circuit breaker protection
    return this.manager.getComponentsCount(scriptId, includeDeleted);
  }

  /**
   * Get circuit breaker metrics for all operations
   */
  getCircuitBreakerStats(): Map<string, CircuitBreaker.Stats> {
    const stats = new Map();
    this.circuitBreakers.forEach((breaker, name) => {
      stats.set(name, breaker.stats);
    });
    return stats;
  }

  /**
   * Get optimistic locking metrics from underlying manager
   */
  getMetrics(): OptimisticLockMetrics {
    return this.manager.getMetrics();
  }

  /**
   * Reset all metrics
   */
  resetMetrics(): void {
    this.manager.resetMetrics();
    this.circuitBreakers.forEach(breaker => {
      breaker.clearCache();
    });
  }

  /**
   * Get offline queue size from Redis
   */
  async getOfflineQueueSize(): Promise<number> {
    try {
      return await this.redis.llen(this.QUEUE_KEY);
    } catch (error) {
      console.error('Error getting queue size from Redis:', error);
      return 0;
    }
  }

  /**
   * Get offline queue size synchronously (for compatibility)
   */
  getOfflineQueueSizeSync(): number {
    // This is a legacy method for backward compatibility
    // In real Redis implementation, queue size should be async
    return 0;
  }

  /**
   * Clear offline queue in Redis
   */
  async clearOfflineQueue(): Promise<void> {
    try {
      await this.redis.del(this.QUEUE_KEY);
    } catch (error) {
      console.error('Error clearing queue in Redis:', error);
    }
  }

  /**
   * Get persisted queue size (Redis implementation)
   */
  async getPersistedQueueSize(): Promise<number> {
    return await this.getOfflineQueueSize();
  }

  /**
   * Get queue contents for testing/debugging
   */
  async getQueueContents(): Promise<Array<{ operation: string; params: unknown; timestamp: number }>> {
    try {
      const items = await this.redis.lrange(this.QUEUE_KEY, 0, -1);
      return items.map(item => JSON.parse(item));
    } catch (error) {
      console.error('Error getting queue contents from Redis:', error);
      return [];
    }
  }

  /**
   * Check Redis connection status
   */
  isRedisConnected(): boolean {
    return this.redis.status === 'ready';
  }

  /**
   * Get worker process status with monitoring metrics
   * Critical-Engineer: Added DLQ monitoring and queue depth tracking
   */
  async getWorkerProcessStatus() {
    const [queueSize, dlqSize, processingSize] = await Promise.all([
      this.redis.llen(this.QUEUE_KEY),
      this.redis.llen(this.DLQ_KEY),
      this.redis.llen(`${this.PROCESSING_KEY}:${this.workerId}`)
    ]);

    return {
      isRunning: this.workerProcessActive,
      workerId: this.workerId,
      queueSize,
      dlqSize,
      processingSize,
      processedCount: this.workerStats.processedCount,
      errorCount: this.workerStats.errorCount,
      dlqCount: this.workerStats.dlqCount,
      lastProcessedAt: this.workerStats.lastProcessedAt
    };
  }

  /**
   * Get Dead Letter Queue contents for debugging
   */
  async getDLQContents(): Promise<Array<unknown>> {
    try {
      const items = await this.redis.lrange(this.DLQ_KEY, 0, -1);
      return items.map(item => JSON.parse(item));
    } catch (error) {
      console.error('Error getting DLQ contents from Redis:', error);
      return [];
    }
  }

  /**
   * Reprocess items from Dead Letter Queue
   */
  async reprocessDLQItems(maxItems = 10): Promise<number> {
    try {
      let reprocessedCount = 0;

      for (let i = 0; i < maxItems; i++) {
        const dlqItemStr = await this.redis.rpop(this.DLQ_KEY);
        if (!dlqItemStr) break;

        const dlqItem = JSON.parse(dlqItemStr);

        // Reset retry count and re-queue
        delete dlqItem.retryCount;
        delete dlqItem.lastError;
        delete dlqItem.lastRetryAt;
        delete dlqItem.movedToDLQAt;
        delete dlqItem.finalError;

        await this.redis.lpush(this.QUEUE_KEY, JSON.stringify(dlqItem));
        reprocessedCount++;
      }

      return reprocessedCount;
    } catch (error) {
      console.error('Error reprocessing DLQ items:', error);
      return 0;
    }
  }

  /**
   * Stop worker process gracefully and recover orphaned items
   * Critical-Engineer: Prevent data loss on shutdown
   */
  async stopWorkerProcess(): Promise<void> {
    this.workerProcessActive = false;

    try {
      // Move any orphaned items from processing back to main queue
      const orphanedItems = await this.redis.lrange(`${this.PROCESSING_KEY}:${this.workerId}`, 0, -1);

      for (const item of orphanedItems) {
        await this.redis.lpush(this.QUEUE_KEY, item);
      }

      // Clear the processing queue
      await this.redis.del(`${this.PROCESSING_KEY}:${this.workerId}`);

      console.info(`Recovered ${orphanedItems.length} orphaned items during shutdown`);
    } catch (error) {
      console.error('Error during graceful shutdown:', error);
    } finally {
      await this.redis.disconnect();
    }
  }

  /**
   * Health check method for monitoring
   */
  async healthCheck(): Promise<{ status: string; details: unknown }> {
    try {
      await this.redis.ping();
      const stats = await this.getWorkerProcessStatus();

      return {
        status: 'healthy',
        details: {
          redis: 'connected',
          worker: this.workerProcessActive ? 'running' : 'stopped',
          ...stats
        }
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        details: {
          redis: 'disconnected',
          error: error instanceof Error ? error.message : String(error)
        }
      };
    }
  }

  /**
   * Manually open a circuit breaker (for testing or emergency)
   */
  openCircuitBreaker(operation: string): void {
    const breaker = this.circuitBreakers.get(operation);
    if (breaker) {
      breaker.open();
    }
  }

  /**
   * Manually close a circuit breaker (for testing or recovery)
   */
  closeCircuitBreaker(operation: string): void {
    const breaker = this.circuitBreakers.get(operation);
    if (breaker) {
      breaker.close();
    }
  }
}

// Export for use in application
export default ResilientScriptComponentManager;