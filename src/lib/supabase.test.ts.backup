/**
 * Supabase Client Configuration Tests
 *
 * TRACED Protocol: TEST FIRST (RED) - Failing tests before implementation
 * Tests authentication and real-time collaboration foundation
 */

// Context7: consulted for vitest
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
// Context7: consulted for @supabase/supabase-js
import { createClient } from '@supabase/supabase-js';
import { auth, getUserRole, roles, type UserRole } from './supabase';

// Mock environment variables
vi.mock('import.meta', () => ({
  env: {
    VITE_SUPABASE_URL: 'https://test.supabase.co',
    VITE_SUPABASE_ANON_KEY: 'test-anon-key',
  },
}));

// Mock Supabase client
vi.mock('@supabase/supabase-js', () => ({
  createClient: vi.fn(),
}));

describe('Supabase Client Configuration', () => {
  let mockSupabaseClient: any;

  beforeEach(() => {
    // Reset mocks
    vi.clearAllMocks();

    // Create mock Supabase client
    mockSupabaseClient = {
      auth: {
        signInWithPassword: vi.fn(),
        signUp: vi.fn(),
        signOut: vi.fn(),
        getUser: vi.fn(),
        getSession: vi.fn(),
        onAuthStateChange: vi.fn(),
      },
      from: vi.fn(),
    };

    (createClient as any).mockReturnValue(mockSupabaseClient);
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('Client Initialization', () => {
    it('should create Supabase client with correct configuration', () => {
      expect(createClient).toHaveBeenCalledWith(
        'https://test.supabase.co',
        'test-anon-key',
        expect.objectContaining({
          auth: expect.objectContaining({
            persistSession: true,
            autoRefreshToken: true,
            detectSessionInUrl: true,
            storageKey: 'eav-orchestrator-auth',
          }),
          realtime: expect.objectContaining({
            params: expect.objectContaining({
              eventsPerSecond: 10,
            }),
          }),
        })
      );
    });

    it('should throw error if environment variables are missing', () => {
      // Temporarily override environment variables
      const originalEnv = vi.importActual('import.meta');
      vi.mock('import.meta', () => ({
        env: {},
      }));

      expect(() => {
        // Re-import to trigger initialization
        require('./supabase');
      }).toThrow('Missing Supabase environment variables');

      // Restore original mock
      vi.mock('import.meta', () => originalEnv);
    });
  });

  describe('Authentication Functions', () => {
    describe('signIn', () => {
      it('should sign in user with email and password', async () => {
        const mockUser = { id: 'user-123', email: 'test@example.com' };
        const mockSession = { access_token: 'token-123' };

        mockSupabaseClient.auth.signInWithPassword.mockResolvedValue({
          data: { user: mockUser, session: mockSession },
          error: null,
        });

        const result = await auth.signIn('test@example.com', 'password123');

        expect(mockSupabaseClient.auth.signInWithPassword).toHaveBeenCalledWith({
          email: 'test@example.com',
          password: 'password123',
        });
        expect(result).toEqual({ user: mockUser, session: mockSession });
      });

      it('should throw error on sign in failure', async () => {
        const mockError = new Error('Invalid credentials');
        mockSupabaseClient.auth.signInWithPassword.mockResolvedValue({
          data: null,
          error: mockError,
        });

        await expect(auth.signIn('test@example.com', 'wrong')).rejects.toThrow('Invalid credentials');
      });
    });

    describe('signUp', () => {
      it('should sign up new user with metadata', async () => {
        const mockUser = { id: 'user-456', email: 'new@example.com' };
        mockSupabaseClient.auth.signUp.mockResolvedValue({
          data: { user: mockUser },
          error: null,
        });

        const result = await auth.signUp('new@example.com', 'password123', {
          name: 'Test User',
          role: 'freelancer',
        });

        expect(mockSupabaseClient.auth.signUp).toHaveBeenCalledWith({
          email: 'new@example.com',
          password: 'password123',
          options: {
            data: {
              name: 'Test User',
              role: 'freelancer',
            },
          },
        });
        expect(result).toEqual({ user: mockUser });
      });
    });

    describe('signOut', () => {
      it('should sign out current user', async () => {
        mockSupabaseClient.auth.signOut.mockResolvedValue({
          error: null,
        });

        await auth.signOut();
        expect(mockSupabaseClient.auth.signOut).toHaveBeenCalled();
      });
    });

    describe('getUser', () => {
      it('should return current user', async () => {
        const mockUser = { id: 'user-789', email: 'current@example.com' };
        mockSupabaseClient.auth.getUser.mockResolvedValue({
          data: { user: mockUser },
          error: null,
        });

        const user = await auth.getUser();
        expect(user).toEqual(mockUser);
      });
    });

    describe('getSession', () => {
      it('should return current session', async () => {
        const mockSession = { access_token: 'session-token' };
        mockSupabaseClient.auth.getSession.mockResolvedValue({
          data: { session: mockSession },
          error: null,
        });

        const session = await auth.getSession();
        expect(session).toEqual(mockSession);
      });
    });

    describe('onAuthStateChange', () => {
      it('should register auth state change listener', () => {
        const callback = vi.fn();
        const unsubscribe = vi.fn();
        mockSupabaseClient.auth.onAuthStateChange.mockReturnValue({ unsubscribe });

        const result = auth.onAuthStateChange(callback);

        expect(mockSupabaseClient.auth.onAuthStateChange).toHaveBeenCalledWith(callback);
        expect(result).toEqual({ unsubscribe });
      });
    });
  });

  describe('User Role Management', () => {
    describe('getUserRole', () => {
      it('should fetch user role from database', async () => {
        const mockFrom = vi.fn().mockReturnThis();
        const mockSelect = vi.fn().mockReturnThis();
        const mockEq = vi.fn().mockReturnThis();
        const mockSingle = vi.fn().mockResolvedValue({
          data: { role: 'admin' },
          error: null,
        });

        mockSupabaseClient.from = mockFrom;
        mockFrom.mockReturnValue({
          select: mockSelect,
        });
        mockSelect.mockReturnValue({
          eq: mockEq,
        });
        mockEq.mockReturnValue({
          single: mockSingle,
        });

        const role = await getUserRole('user-123');

        expect(mockFrom).toHaveBeenCalledWith('user_profiles');
        expect(mockSelect).toHaveBeenCalledWith('role');
        expect(mockEq).toHaveBeenCalledWith('user_id', 'user-123');
        expect(role).toBe('admin');
      });

      it('should return VIEWER role on error', async () => {
        mockSupabaseClient.from = vi.fn().mockReturnValue({
          select: vi.fn().mockReturnValue({
            eq: vi.fn().mockReturnValue({
              single: vi.fn().mockResolvedValue({
                data: null,
                error: new Error('User not found'),
              }),
            }),
          }),
        });

        const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
        const role = await getUserRole('unknown-user');

        expect(role).toBe(roles.VIEWER);
        expect(consoleSpy).toHaveBeenCalledWith('Error fetching user role:', expect.any(Error));

        consoleSpy.mockRestore();
      });

      it('should return VIEWER role if no role in data', async () => {
        mockSupabaseClient.from = vi.fn().mockReturnValue({
          select: vi.fn().mockReturnValue({
            eq: vi.fn().mockReturnValue({
              single: vi.fn().mockResolvedValue({
                data: { role: null },
                error: null,
              }),
            }),
          }),
        });

        const role = await getUserRole('user-no-role');
        expect(role).toBe(roles.VIEWER);
      });
    });

    describe('Role Constants', () => {
      it('should define all 5 user roles', () => {
        expect(roles.ADMIN).toBe('admin');
        expect(roles.INTERNAL).toBe('internal');
        expect(roles.FREELANCER).toBe('freelancer');
        expect(roles.CLIENT).toBe('client');
        expect(roles.VIEWER).toBe('viewer');
      });

      it('should export UserRole type', () => {
        // Type checking - this will be validated at compile time
        const testRole: UserRole = 'admin';
        expect(testRole).toBe('admin');
      });
    });
  });
});